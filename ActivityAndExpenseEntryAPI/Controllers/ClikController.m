//
//  ClikController.m
//  ActivityAndExpenseEntryAPI
//
//  This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io )
//
#import "ClikController.h"

@implementation ClikController

/**
* List enumerators
* @param    mandant    Required parameter: The mandant to operate on
* @param    type    Required parameter: The enumerator type
* @param    parentProject    Optional parameter: The parent project to filter by
* @param    xPage    Optional parameter: A server defined page reference returned in the header "x-next-page"
* @param    xPageSize    Optional parameter: How many items to return in a page
* @return	Returns the void response from the API call */
- (void) listEnumeratorsAsyncWithMandant:(NSString*) mandant
                type:(enum EnumerationTypeEnum) type
                parentProject:(NSString*) parentProject
                xPage:(NSString*) xPage
                xPageSize:(NSNumber*) xPageSize
                completionBlock:(CompletedGetListEnumerators) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/enumerators/{type}"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant,
                    @"type": [EnumerationTypeEnumHelper stringFromEnumerationTypeEnum: (enum EnumerationTypeEnum) type withDefault: [NSNull null]]
                }];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withQueryParameters: @{
                    @"parentProject": (nil != parentProject) ? parentProject : [NSNull null]
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"x-page": (nil != xPage) ? xPage : [NSNull null],
        @"x-page-size": (nil != xPageSize) ? xPageSize : @100
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] get: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 404)
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"Enumeration does not exist"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             NSArray<Enumerator> * _result = (NSArray<Enumerator>*) [Enumerator arrayOfModelsFromDictionaries:
                [APIHelper jsonDeserializeArray: _strResult] error: nil];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* Read a specific enumerator
* @param    mandant    Required parameter: The mandant to operate on
* @param    type    Required parameter: The enumerator type
* @param    mid    Required parameter: The id of the enumerator to retrieve
* @return	Returns the void response from the API call */
- (void) getReadASpecificEnumeratorAsyncWithMandant:(NSString*) mandant
                type:(enum EnumerationTypeEnum) type
                mid:(NSString*) mid
                completionBlock:(CompletedGetReadASpecificEnumerator) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/enumerators/{type}/{id}"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant,
                    @"type": [EnumerationTypeEnumHelper stringFromEnumerationTypeEnum: (enum EnumerationTypeEnum) type withDefault: [NSNull null]],
                    @"id": mid
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json"
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] get: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 404)
             _statusError = [[APIError alloc] initWithReason: @"Enumerator does not exist"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             Enumerator* _result = (Enumerator*) [APIHelper jsonDeserialize: _strResult
                toClass: Enumerator.class];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* Read constraints for a single enumerator
* @param    mandant    Required parameter: The mandant to operate on
* @param    enumeratorType    Required parameter: The enumerator type to retrieve restrictions for
* @param    combinationConstraints    Required parameter: Includes/excludes the property combinationConstraints. Must be set explicitly to false for performance reasons.
* @param    xPage    Optional parameter: A server defined page reference returned in the header "x-next-page"
* @param    xPageSize    Optional parameter: How many items to return in a page
* @return	Returns the void response from the API call */
- (void) getReadConstraintsForASingleEnumeratorAsyncWithMandant:(NSString*) mandant
                enumeratorType:(enum EnumerationTypeEnum) enumeratorType
                combinationConstraints:(BOOL) combinationConstraints
                xPage:(NSString*) xPage
                xPageSize:(NSNumber*) xPageSize
                completionBlock:(CompletedGetReadConstraintsForASingleEnumerator) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/enumeratorConstraints/{enumeratorType}/"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant,
                    @"enumeratorType": [EnumerationTypeEnumHelper stringFromEnumerationTypeEnum: (enum EnumerationTypeEnum) enumeratorType withDefault: [NSNull null]]
                }];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withQueryParameters: @{
                    @"combinationConstraints": (combinationConstraints ? @"true" : @"false")
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"x-page": (nil != xPage) ? xPage : [NSNull null],
        @"x-page-size": (nil != xPageSize) ? xPageSize : @100
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] get: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 404)
             _statusError = [[APIError alloc] initWithReason: @"Enumeration does not exist"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             NSArray<EnumeratorConstraints> * _result = (NSArray<EnumeratorConstraints>*) [EnumeratorConstraints arrayOfModelsFromDictionaries:
                [APIHelper jsonDeserializeArray: _strResult] error: nil];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* Read constraints for a single enumerator
* @param    mandant    Required parameter: The mandant to operate on
* @param    enumeratorType    Required parameter: The enumerator type to retrieve restrictions for
* @param    enumeratorId    Required parameter: The id of the enumerator to retrieve restrictions for
* @param    combinationConstraints    Optional parameter: Includes/excludes the property combinationConstraints
* @return	Returns the void response from the API call */
- (void) getReadConstraintsForASingleEnumeratorAsyncWithMandant:(NSString*) mandant
                enumeratorType:(enum EnumerationTypeEnum) enumeratorType
                enumeratorId:(NSString*) enumeratorId
                combinationConstraints:(NSNumber*) combinationConstraints
                completionBlock:(CompletedGetReadConstraintsForASingleEnumerator) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/enumeratorConstraints/{enumeratorType}/{enumeratorId}"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant,
                    @"enumeratorType": [EnumerationTypeEnumHelper stringFromEnumerationTypeEnum: (enum EnumerationTypeEnum) enumeratorType withDefault: [NSNull null]],
                    @"enumeratorId": enumeratorId
                }];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withQueryParameters: @{
                    @"combinationConstraints": (nil != combinationConstraints) ? combinationConstraints : @YES
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json"
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] get: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 404)
             _statusError = [[APIError alloc] initWithReason: @"The enumeration or enumerator does not exist"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             EnumeratorConstraints* _result = (EnumeratorConstraints*) [APIHelper jsonDeserialize: _strResult
                toClass: EnumeratorConstraints.class];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* List entries
* @param    mandant    Required parameter: The mandant to operate on
* @param    status    Optional parameter: One or more statuses (disjunctive)
* @param    startDate    Optional parameter: The minimum date of entries
* @param    xPage    Optional parameter: A server defined page reference returned in the header "x-next-page"
* @param    xPageSize    Optional parameter: How many items to return in a page
* @return	Returns the void response from the API call */
- (void) listEntriesAsyncWithMandant:(NSString*) mandant
                status:(NSArray<NSNumber*>*) status
                startDate:(NSString*) startDate
                xPage:(NSString*) xPage
                xPageSize:(NSNumber*) xPageSize
                completionBlock:(CompletedGetListEntries) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/entries"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant
                }];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withQueryParameters: @{
                    @"status": [EntryStatusEnumHelper stringArrayFromEntryStatusEnumArray: status],
                    @"startDate": (nil != startDate) ? startDate : [NSNull null]
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"x-page": (nil != xPage) ? xPage : [NSNull null],
        @"x-page-size": (nil != xPageSize) ? xPageSize : @100
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] get: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             NSArray<Entry> * _result = (NSArray<Entry>*) [Entry arrayOfModelsFromDictionaries:
                [APIHelper jsonDeserializeArray: _strResult] error: nil];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* Create or update one or multiple entries independently
* @param    mandant    Required parameter: The mandant to operate on
* @param    body    Optional parameter: Example: 
* @return	Returns the void response from the API call */
- (void) createOrUpdateOneOrMultipleEntriesIndependentlyAsyncWithMandant:(NSString*) mandant
                body:(NSArray<Entry> *) body
                completionBlock:(CompletedPostCreateOrUpdateOneOrMultipleEntriesIndependently) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/entries"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"content-type": @"application/json; charset=utf-8"
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response 
    HttpRequest* _request = [[self clientInstance] postBody: ^(HttpBodyRequest* _request)
    {
        [_request setBody: [[APIHelper jsonSerialize: body] dataUsingEncoding:NSUTF8StringEncoding]]; //set request body
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 400)
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"Malformed or invalid request"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             NSArray<Entry> * _result = (NSArray<Entry>*) [Entry arrayOfModelsFromDictionaries:
                [APIHelper jsonDeserializeArray: _strResult] error: nil];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* Read an entry by its id
* @param    mandant    Required parameter: The mandant to operate on
* @param    mid    Required parameter: The id of the entry to retrieve
* @return	Returns the void response from the API call */
- (void) getReadAnEntryByItsIdAsyncWithMandant:(NSString*) mandant
                mid:(NSString*) mid
                completionBlock:(CompletedGetReadAnEntryByItsId) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/entries/{id}"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant,
                    @"id": mid
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json"
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] get: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 404)
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"Entry not found"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             Entry* _result = (Entry*) [APIHelper jsonDeserialize: _strResult
                toClass: Entry.class];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* Create or update an entry by id
* @param    mandant    Required parameter: The mandant to operate on
* @param    mid    Required parameter: The id of the entry to retrieve
* @param    body    Optional parameter: Example: 
* @return	Returns the void response from the API call */
- (void) createOrUpdateAnEntryByIdAsyncWithMandant:(NSString*) mandant
                mid:(NSString*) mid
                body:(Entry*) body
                completionBlock:(CompletedPutCreateOrUpdateAnEntryById) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/entries/{id}"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant,
                    @"id": mid
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json",
        @"content-type": @"application/json; charset=utf-8"
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response 
    HttpRequest* _request = [[self clientInstance] putBody: ^(HttpBodyRequest* _request)
    {
        [_request setBody: [[APIHelper jsonSerialize: body] dataUsingEncoding:NSUTF8StringEncoding]]; //set request body
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 400)
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"Malformed or invalid request"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, nil, _statusError);
         }
         else
         {
             //return _response to API caller
             NSString* _strResult = [(HttpStringResponse*)_response body];
             Entry* _result = (Entry*) [APIHelper jsonDeserialize: _strResult
                toClass: Entry.class];

 
             //announce completion with success
             onCompleted(YES, _context, _result, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, nil, _error);
     }];
}

/**
* Delete a an entry by id
* @param    mandant    Required parameter: The mandant to operate on
* @param    mid    Required parameter: The id of the entry to retrieve
* @return	Returns the void response from the API call */
- (void) deleteAAnEntryByIdAsyncWithMandant:(NSString*) mandant
                mid:(NSString*) mid
                completionBlock:(CompletedDeleteAAnEntryById) onCompleted
{
    //the base uri for api requests
    NSString* _baseUri = [NSString stringWithString: (NSString*) Configuration_BaseUri];

    //prepare query string for API call
    NSMutableString* _queryBuilder = [NSMutableString stringWithString: _baseUri]; 
    [_queryBuilder appendString: @"/mandants/{mandant}/entries/{id}"];

    //process optional query parameters
    [APIHelper appendUrl: _queryBuilder withTemplateParameters: @{
                    @"mandant": mandant,
                    @"id": mid
                }];

    //validate and preprocess url
    NSString* _queryUrl = [APIHelper cleanUrl: _queryBuilder];

    //preparing request headers
    NSMutableDictionary* _headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0"
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: _headers];


    //prepare the request and fetch response  
    HttpRequest* _request = [[self clientInstance] delete: ^(HttpRequest* _request) 
    { 
        [_request setQueryUrl: _queryUrl]; //set request url        
        [_request setHeaders: _headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: _request
     success: ^(id _context, HttpResponse *_response) {
         //Error handling using HTTP status codes
         NSError* _statusError = nil;

         //Error handling using HTTP status codes 
         if (_response.statusCode == 404)
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"Entry not found"
                                               andContext:_context];
         else if((_response.statusCode < 200) || (_response.statusCode > 208)) //[200,208] = HTTP OK
             _statusError = [[ProblemDetailsException alloc] initWithReason: @"unexpected error"
                                               andContext:_context];

         if(_statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, _context, _statusError);
         }
         else
         {
             //return _response to API caller

             onCompleted(YES, _context, nil);
         }
     } failure:^(id _context, NSError *_error) {
 
         //announce completion with failure
         onCompleted(NO, _context, _error);
     }];
}


@end